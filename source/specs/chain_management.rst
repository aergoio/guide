chain management
==================
The chainServcie module is responsible for managing the chain.

ChainServcie performs the following tasks in large part:

1. insert block to chain
2. reorganization
3. syncronize chain

insert block to chain
---------------------------
There are two cases in which Chainservcie adds blocks:

1. Block generated by Block Factory
When BP nodes are in the order in which they are created, blocks are created in the Block Factory.

Block Factory performs all transactions and forwards the block to the ChainService. Therefore, the execution results are included with the block.

The execution results include the results of the transaction, reception, and State changed entry indicating the change to the account.

The chain service stores information related to blocks in the chainDB and information about accounts in the StateDB.

2. Block received from another Peer node
The blocks received from the other Peer nodes are three main cases:

- Orphan block
This is the case if the parent block has not yet been stored in the DB. Orphan blocks are stored in the orphan block cache on memory.

Then, when the parent block is received, it is removed from the organ block cache and reprocessed.

- Side branch block
In case the parent block is stored but is not part of the main branch. In this case, the block is not performed and only the block info{hash, block} is stored.

- main branch block
In case the head of the main branch is the next block.
In this case, the blocks are stored after performing the transactions.

The process for storing blocks in the main branch is as follows.

1. validation before execution
2. execute transactions
3. apply changed entries of Account to State SMT
4. validate after execution
5. save State SMT to StateDB
6. save chain meta data to Chain DB

Block validation
---------------------
The blocks received in the network may not be valid, so a number of checks are made.

Pre-execution execution
^^^^^^^^^^^^^^^^^^^^^^^^^^
- Consensus validation

  Validate the block generated by the valid BP through block creation time and signature.
  
- Transaction merkle validation

  Validate that the transactions were not forged.
  The Verifier module generates a Merkel tree with the transactions and checks if it is the same as the Transaction Merkel    root stored in the Block header.

The validator module can ensure that the block was generated from a valid BP and the transaction contained in the block was not forged.

Post-execution validation
^^^^^^^^^^^^^^^^^^^^^^^^^^
- State root validation

  The Validate module checks if the changed state root node hash is the same as the blocksRootHash stored in the block head.
  
- Receipt merkle validation

  The Validate module generates a merkel tree with the reciepts generated as a result of the transactions and checks if they are identical to the recipts stored in the block header.

These checks ensure that the results of the transaction contained in the block are the same as the results of the BP node that generated the block.

reorgnize process
--------------------

The ChainService module selects and maintains the longest chain as the main branch.

The side branches are not executed and only the block info is stored in the DB.

If the side branch received from another peer is longer than the main branch held by the node, the side branch is changed to the main branch. This is called the reorgnize process.

The reorgnize is performed as follows.

1. find common ancestor between main branch and side branch
2. rollback master branch
3. rollforward side branch
4. swap chain meta

- find common ancestor
  Syncer finds the last common ancestor block of the main branch and side branch.

- rollback master branch
    State is reset to the point at which the common ancestor block was executed

- rollforward side branch
    Syncer runs from the next number of the common ancestor block to the head block of the side branch.
    At this time, only StateDB is changed and Chain info and Tx info are not changed.

- swap chain meta
    Syncer do not change the chain info during rollback and rollforward to atomically change the chain. 
    Change the chain meta information after the previous process has been successfully completed.
    At this time, chain info and transaction info are deleted for the rollbacked block, and new chain info and transaction info are added for the rollforwarded block.

    Transactions belonging to rollbacked blocks but not included in rollforwarded blocks are returned to mempool. This is to prevent transaction loss.


Synchronize process
--------------------------
If you add a new node or restart the node that was temporarily stopped, you need to get the latest chain information from the existing nodes. This is called the Synchonize process.
The Syncer module is responsible for synchronization.

The situation that causes sync is as follows
 - When the peer goes through a handshake process to connect, the height of the chain of the remote peer is higher than the current node
 - If the height of the block notified in the peer is higher than the head of the current main branch

The Syncer specifies the node that sent the block that caused the sync to the target node and synchronizes with the chain of that node.

To synchronize a long chain, a large amount of block information must be received from the peer node.

This is likely to cause a performance degrade at the peer node.

Therefore, it gets information from as many peers as possible to distribute the load.

Synchronize step
^^^^^^^^^^^^^^^^^^^
1. find common ancestor
Syncer finds the last common ancestor of the current node chain and the target node chain.

2. Get Hashes
It gets the hashes of the block after the common ancestor from the target node.

3. Get Blocks
N blocks are requested from all valid peers connected to the current node.

4. Insert blocks to chain
The received block is added to the chain by making an insert request to the ChainService module.

2, 3, and 4 are performed in parallel. Most of the time is spent in the insert part of the chain. While inserting
Overlapping operations on the network to receive hash and block
